#!/usr/bin/env bash

####################################################################################################
#
# pingpong-mgr: PingPong Manager v1.0.0 | GPLv3.0 Permissive License | loopyd <loopyd@github.com> 2024
#
# This script is a bash script that manages the PingPong service on a Linux systems.  It provides
# a simple CLI interface to install, uninstall, start, stop, and restart the PingPong service.
#
#---------------------------------------------------------------------------------------------------
#
# Features:
#
#   - Automated unattended installation/uninstallation of pingpong to the system
#   - It supports multiuser environments and can be run as any user to manage the PingPong service (provided that they are a member of the docker group)
#   - It can start, stop, and restart the PingPong service with PID process management
#   - It can load and save PingPong configuration from a centralized config.json file, which removes the need to manually configure the service
#     and also enables IoC deployments of the PingPong service through cloud-init and other such tools.
#   - It can be invoked in a systemd service file/supervisord or cron job to automatically bring
#     up the PingPong service on system boot for nearly zero downtime
#   - It has readable command line options and help messages for easy use
#
#---------------------------------------------------------------------------------------------------
#
# If you like my work, please consider supporting me by buying me a coffee:
#
# 	Solana Wallet Address: tiAq2vb9xqXphzBkctukRah8UrpxRfjhKWjVj1w1YCp
#   Etherium Wallet Address (mainnet): 0xf48a58cE905f6CDaCEc5B37740e9854da40aDF43
#
# WARNING:  Please refrain from sending donations to me over BSC netowrk as I am a US citizen and Binance Smart Chain is not compliant with US regulations.
#           I am not responsible for any lost funds due to sending me donations (i. e.: choosing the wrong wallet address, sending the wrong token, etc.)
#
#---------------------------------------------------------------------------------------------------
#
# Usage: pingpong-mgr <action> [options]
#
# Actions:
#   install            Install pingpong to the system
#   uninstall          Uninstall pingpong from the system
#   start              Start the pingpong service
#   stop               Stop the pingpong service
#   restart            Restart the pingpong service
#
# You can run the script with the -h or --help option to get help on the specific action.
#
####################################################################################################

declare -ra CARGS=($@)
CSCRIPT_DIR=$(dirname $0)

# Environment variables used by the script
ACTION=${ACTION:-}
PINGPONG_INSTALL_PREFIX=${PINGPONG_INSTALL_PREFIX:-""}
PINGPONG_CONFIG_FILE=${PINGPONG_CONFIG_FILE:-}
PINGPONG_USERNAME=${PINGPONG_USERNAME:-}
declare -a PINGPONG_ARGS=()
PINGPONG_DEVICE_KEY=${PINGPONG_DEVICE_KEY:-}
PINGPONG_AIOZ_TOKEN=${PINGPONG_AIOZ_TOKEN:-}
PINGPONG_AIOG_TOKEN=${PINGPONG_AIOG_TOKEN:-}
PINGPONG_GRASS_TOKEN=${PINGPONG_GRASS_TOKEN:-}

# Terminal colors
C_RED=$(tput setaf 1)
C_GREEN=$(tput setaf 2)
C_YELLOW=$(tput setaf 3)
C_BLUE=$(tput setaf 4)
C_MAGENTA=$(tput setaf 5)
C_CYAN=$(tput setaf 6)
C_WHITE=$(tput setaf 7)
C_RESET=$(tput sgr0)
C_BOLD=$(tput bold)
C_UNDERLINE=$(tput smul)

####################################################################################################
# Logging functions
####################################################################################################

# Display program error messages
function error() {
	echo -e "${C_RED}${C_BOLD}Error:${C_RESET} $1" 1>&2
}

# Display program warning messages
function warning() {
	echo -e "${C_YELLOW}${C_BOLD}Warning:${C_RESET} $1" 1>&2
}

# Display program info messages
function info() {
	echo -e "${C_CYAN}${C_BOLD}Info:${C_RESET} $1"
}

# Display program success messages
function success() {
	echo -e "${C_GREEN}${C_BOLD}Success:${C_RESET} $1"
}

# Error trap function
function error_trap() {
	local RET=$?
	if [ $RET -ne 0 ]; then
		error "Script failed with exit code: $RET"
	fi
	exit $RET
}
trap error_trap EXIT ERR SIGINT SIGTERM

####################################################################################################
# CLI functions
####################################################################################################

# usage: Display program usage information
function usage() {
	cat <<-'EOF'
		PingPong Manager Program v1.0.0
		by loopyd <loopyd@github.com> 2024 | GPLv3.0 permissive license

	EOF
	case "$ACTION" in
	install)
		cat <<-'EOF'
			Usage: $0 install [options]

			Install Options:
				-i, --install-prefix        Installation directory prefix

			Core Options:
				-h, --help            Display this help message
		EOF
		;;
	uninstall)
		cat <<-'EOF'
			Usage: $0 uninstall [options]

			Uninstall Options:
				-i, --install-prefix        Installation directory prefix

			Core Options:
				-h, --help              Display this help message
		EOF
		;;
	start)
		cat <<-'EOF'
			Usage: $0 start [options]

			Start Options:
				-i, --install-prefix        Installation directory prefix
				-c, --config-file           Configuration file
				-u, --username              Username to run the service as

			Core Options:
				-h, --help              Display this help message
		EOF
		;;
	stop)
		cat <<-'EOF'
			Usage: $0 stop [options]

			Stop Options:
				-i, --install-prefix        Installation directory prefix
				-u, --username              Username the service is running as

			Core Options:
				-h, --help            Display this help message
		EOF
		;;
	restart)
		cat <<-'EOF'
			Usage: $0 restart [options]

			Restart Options:
				-i, --install-prefix        Installation directory prefix
				-u, --username              Username the service is running as
				-c, --config-file           Configuration file

			Core Options:
				-h, --help            Display this help message
		EOF
		;;
	configure)
		cat <<-'EOF'
			Usage: $0 configure [options]

			Configure Options:
				-c, --config-file           Configuration file
				-d, --device-key            Device key
				-a, --aioz-token            AIOZ token
				-g, --aiog-token            AIOG token
				-r, --grass-token           GRASS token

			Core Options:
				-h, --help            Display this help message
		EOF
		;;
	*)
		cat <<-'EOF'
			Usage: $0 <action> [options]

			Actions:
				install            Install pingpong to the system
				uninstall          Uninstall pingpong from the system
				start              Start the pingpong service
				stop               Stop the pingpong service
				restart            Restart the pingpong service

			You can run the script with the -h or --help option to get help on the specific action.
		EOF
		;;
	esac
	exit 1
}

# parse_args:  Parse command line arguments for the script
function parse_args() {
	local ARGS
	ARGS=($@)
	if [[ ${#ARGS[@]} -eq 0 ]]; then
		return 0
	fi
	ACTION=${ARGS[0]}
	if [[ -z $ACTION ]]; then
		error "No action specified"
		usage
	fi
	ARGS=(${ARGS[@]:1})
	case "$ACTION" in
	install)
		while [ ${#ARGS[@]} -gt 0 ]; do
			case ${ARGS[0]} in
			-h | --help)
				usage
				;;
			-i | --install-prefix)
				PINGPONG_INSTALL_PREFIX=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			*)
				error "Unknown argument: ${ARGS[0]}" 1>&2
				usage
				;;
			esac
		done
		;;
	uninstall)
		while [ ${#ARGS[@]} -gt 0 ]; do
			case ${ARGS[0]} in
			-h | --help)
				usage
				;;
			-i | --install-prefix)
				PINGPONG_INSTALL_PREFIX=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			*)
				error "Unknown argument: ${ARGS[0]}" 1>&2
				usage
				;;
			esac
		done
		;;
	start)
		while [ ${#ARGS[@]} -gt 0 ]; do
			case ${ARGS[0]} in
			-h | --help)
				usage
				;;
			-i | --install-prefix)
				PINGPONG_INSTALL_PREFIX=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-c | --config-file)
				PINGPONG_CONFIG_FILE=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-u | --username)
				PINGPONG_USERNAME=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			*)
				error "Unknown argument: ${ARGS[0]}" 1>&2
				usage
				;;
			esac
		done
		;;
	stop)
		while [ ${#ARGS[@]} -gt 0 ]; do
			case ${ARGS[0]} in
			-h | --help)
				usage
				;;
			-i | --install-prefix)
				PINGPONG_INSTALL_PREFIX=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-u | --username)
				PINGPONG_USERNAME=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			*)
				error "Unknown argument: ${ARGS[0]}" 1>&2
				usage
				;;
			esac
		done
		;;
	restart)
		while [ ${#ARGS[@]} -gt 0 ]; do
			case ${ARGS[0]} in
			-h | --help)
				usage
				;;
			-i | --install-prefix)
				PINGPONG_INSTALL_PREFIX=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-u | --username)
				PINGPONG_USERNAME=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-c | --config-file)
				PINGPONG_CONFIG_FILE=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			*)
				error "Unknown argument: ${ARGS[0]}" 1>&2
				usage
				;;
			esac
		done
		;;
	configure)
		while [ ${#ARGS[@]} -gt 0 ]; do
			case ${ARGS[0]} in
			-h | --help)
				usage
				;;
			-c | --config-file)
				PINGPONG_CONFIG_FILE=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-d | --device-key)
				PINGPONG_DEVICE_KEY=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-a | --aioz-token)
				PINGPONG_AIOZ_TOKEN=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-g | --aiog-token)
				PINGPONG_AIOG_TOKEN=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			-r | --grass-token)
				PINGPONG_GRASS_TOKEN=${ARGS[1]}
				ARGS=(${ARGS[@]:2})
				;;
			*)
				error "Unknown argument: ${ARGS[0]}" 1>&2
				usage
				;;
			esac
		done
		;;
	*)
		error "Unknown action: $ACTION"
		usage
		;;
	esac
	return 0
}

####################################################################################################
# Helper functions
####################################################################################################

# validate_install_dir: Validate the installation directory of a program
#
# Usage: validate_install_dir <install_dir> <program_name>
#
# Arguments:
#   install_dir: Installation directory of the program
#   program_name: Name of the program
#
# Returns:
#   Installation directory on stdout with return code 0, return code 1 on failure
#
function validate_install_dir() {
	local _value
	_value=$1
	shift 1
	local _program_name
	_program_name=$1
	shift 1
	if [[ -z "${_value}" || "x${_value}x" == "xx" ]]; then
		_value=$(dirname "$(which ${_program_name} || echo \"\")" || echo "")
		if [[ -z "${_value}" || "x${_value}x" == "x.x" ]]; then
			error "Failed to autodetect location of ${_program_name} program"
			return 1
		fi
	fi
	if [ ! -d "${_value}" ]; then
		error "Program ${_program_name} installation directory not found: ${_value}"
		return 1
	fi
	if [ ! -f "${_value}/${_program_name}" ]; then
		error "Program ${_program_name} not found in installation directory: ${_value}"
		return 1
	fi
	echo "${_value}"
	return 0
}

# validate_username: Validate a username
#
# Usage: validate_username <username>
#
# Arguments:
#   username: Username to validate
#
# Returns:
#   Username on stdout with return code 0, return code 1 on failure
#
function validate_username() {
	local _value
	if [ $# -gt 0 ]; then
		_value=$1
		shift 1
	fi
	if [[ -z "${_value}" || "x${_value}x" == "xx" ]]; then
		_value=$(id -un)
	fi
	if ! id -u "${_value}" &>/dev/null; then
		error "User ${_value} does not exist."
		return 1
	fi
	echo "${_value}"
	return 0
}

# validate_boolean: Validate a boolean value
#
# Usage: validate_boolean <value>
#
# Arguments:
#   value: Value to validate
#
# Returns:
#   true or false on stdout with return code 0, return code 1 on failure
function validate_boolean() {
	local _value
	if [ $# -gt 0 ]; then
		_value=$1
		shift 1
	fi
	case ${_value} in
	true | false)
		[[ "${_value}" == "true" ]] && echo true || echo false
		;;
	0 | 1)
		[[ "${_value}" == "1" ]] && echo true || echo false
		;;
	"yes" | "no")
		[[ "${_value}" == "yes" ]] && echo true || echo false
		;;
	"on" | "off")
		[[ "${_value}" == "on" ]] && echo true || echo false
		;;
	*)
		error "Invalid boolean value: ${_value}"
		return 1
		;;
	esac
	return 0
}

# validate_file: Validate a file
#
# Usage: validate_file <file>
#
# Arguments:
#   file: File to validate
#
# Returns:
#   File on stdout with return code 0, return code 1 on failure
#
function validate_file() {
	local _value
	if [ $# -gt 0 ]; then
		_value=$1
		shift 1
	else
		error "No file specified."
		return 1
	fi
	if [ ! -f "${_value}" ]; then
		error "File ${_value} does not exist."
		return 1
	fi
	echo "${_value}"
	return 0
}

# fetch_from_url: Overcomplicated fetch from a web URL
#
# Usage: fetch_from_url <url> <target_dir> [<strip_components>]
#
# Arguments:
#   url: URL to fetch from
#   target_dir: Target directory to put the fetched file(s)
#   strip_components: Number of leading path components to strip, applies to archives only
#
# Returns:
#   0 on success, 1 on failure
#
function fetch_from_url() {
	local url=$1
	local target_dir=$2
	local strip_components=${3:-0}
	if [ -z "$url" ] || [ -z "$target_dir" ]; then
		error "URL and/or target directory not specified"
		return 1
	fi
	local archive_name=$(basename "$url")
	local temp_dir=$(mktemp -d)
	local extract_dir="$temp_dir/extracted"
	info "Downloading $url to $temp_dir/$archive_name"
	curl -L -o "$temp_dir/$archive_name" "$url"
	if [ $? -ne 0 ]; then
		error "Failed to download $url"
		rm -rf "$temp_dir"
		return 1
	fi
	mkdir -p "$extract_dir"
	local extension="${archive_name##*.}"
	info "Extracting $temp_dir/$archive_name to $extract_dir"
	case "$extension" in
	tar.gz | tgz | gz)
		tar --strip-components=$strip_components -xzf "$temp_dir/$archive_name" -C "$extract_dir"
		;;
	tar.bz2 | tbz2 | bz2)
		tar --strip-components=$strip_components -xjf "$temp_dir/$archive_name" -C "$extract_dir"
		;;
	tar.xz | txz | xz)
		tar --strip-components=$strip_components -xJf "$temp_dir/$archive_name" -C "$extract_dir"
		;;
	zip)
		unzip -d "$extract_dir" "$temp_dir/$archive_name"
		if [ $strip_components -gt 0 ]; then
			find "$extract_dir" -mindepth $strip_components -exec mv -t "$extract_dir" -- {} +
			find "$extract_dir" -mindepth 1 -type d -exec rm -rf {} +
		fi
		;;
	rar)
		unrar x "$temp_dir/$archive_name" "$extract_dir"
		if [ $strip_components -gt 0 ]; then
			find "$extract_dir" -mindepth $strip_components -exec mv -t "$extract_dir" -- {} +
			find "$extract_dir" -mindepth 1 -type d -exec rm -rf {} +
		fi
		;;
	7z)
		7z x "$temp_dir/$archive_name" -o"$extract_dir"
		if [ $strip_components -gt 0 ]; then
			find "$extract_dir" -mindepth $strip_components -exec mv -t "$extract_dir" -- {} +
			find "$extract_dir" -mindepth 1 -type d -exec rm -rf {} +
		fi
		;;
	*)
		warning "Unrecognized archive format: $extension. Downloading file as is."
		if [ -f "$target_dir" ]; then
			warning "File $target_dir already exists, overwriting"
			rm -f "$target_dir"
		fi
		mv "$temp_dir/$archive_name" "$target_dir"
		rm -rf "$temp_dir"
		success "Fetched and moved $url to $target_dir"
		return 0
		;;
	esac
	if [ $? -ne 0 ]; then
		error "Failed to extract $temp_dir/$archive_name"
		rm -rf "$temp_dir"
		return 1
	fi
	info "Syncing extracted files from $extract_dir to $target_dir"
	rsync -av --delete "$extract_dir/" "$target_dir/"
	if [ $? -ne 0 ]; then
		error "Failed to sync extracted files to $target_dir"
		rm -rf "$temp_dir"
		return 1
	fi
	rm -rf "$temp_dir"
	success "Fetched, extracted, and synced $url to $target_dir"
	return 0
}

# is_logged_program_with_pid_running: Check if a program ran by run_logged_program_with_pid is running
#
# Usage: is_logged_program_with_pid_running <program_name> [<username>]
#
# Arguments:
#   program_name: Name of the program to check
#   username: User the program is running as (defaults to logged in user)
#
# Returns:
#   0 if the program is running, 1 if it is not
#
function is_logged_program_with_pid_running() {
	local _program_name=$1
	if [ -z "${_program_name}" ]; then
		error "No program name specified"
		return 1
	fi
	local _program_path
	if [[ "${_program_name}" == */* ]]; then
		_program_path=$(dirname "${_program_name}")
		_program_name=$(basename "${_program_name}")
	else
		_program_path=$(dirname "$(which "${_program_name}" || echo "")" || echo "")
	fi
	shift 1
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?

	local _pid_dir _pid_file _pid
	_pid_dir="/var/run/${_program_name}"
	_pid_file="${_pid_dir}/${_username}_${_program_name}.pid"
	if [ ! -f "${_pid_file}" ]; then
		return 1
	fi
	_pid=$(cat "${_pid_file}")
	if kill -0 "${_pid}" 2>/dev/null; then
		return 0
	else
		rm -f "${_pid_file}"
		return 1
	fi
}

# run_logged_program: Run a program with logging and controlled by a PID file
#
# Usage: run_logged_program <program_name> [<username>] [<timeout>] [<retries>] [<program_args>]
#
# Arguments:
#   program_name: Name of the program to run
#   username: User to run the program as (defaults to root)
#   timeout: Timeout duration for each attempt (in seconds)
#   retries: Number of retries for starting the program
#   program_args: Arguments to pass to the program (optional)
#
# Returns:
#   0 on success, 1 on failure
#
function run_logged_program_with_pid() {
	local _program_name=$1
	if [ -z "${_program_name}" ]; then
		error "No program name specified"
		return 1
	fi
	local _program_path
	if [[ "${_program_name}" == */* ]]; then
		_program_path=$(dirname "${_program_name}")
		_program_name=$(basename "${_program_name}")
	else
		_program_path=$(dirname "$(which "${_program_name}" || echo "")" || echo "")
	fi
	shift 1
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _timeout
	if [ $# -gt 0 ]; then
		_timeout=$1
		shift 1
	else
		_timeout=15
	fi
	local _retries
	if [ $# -gt 0 ]; then
		_retries=$1
		shift 1
	else
		_retries=3
	fi
	declare -a _program_args=($*)

	# Straighten out permissions and directories
	local _log_dir _pid_dir _pid_file _log_file
	_log_dir="/var/log/${_program_name}"
	if [ ! -d "$_log_dir" ]; then
		mkdir -p "$_log_dir"
		chmod 1755 "$_log_dir"
		chown root:syslog -R "$_log_dir"
	fi
	_pid_dir="/var/run/${_program_name}"
	if [ ! -d "${_pid_dir}" ]; then
		mkdir -p "${_pid_dir}"
		chmod 1777 "${_pid_dir}"
	fi

	# Run the program
	_pid_file="${_pid_dir}/${_username}_${_program_name}.pid"
	_log_file="${_log_dir}/${_username}_${_program_name}.log"
	if [ -f "${_pid_file}" ] && kill -0 $(cat "${_pid_file}") 2>/dev/null; then
		warning "${_program_name} is already running for user ${_username}."
		return 0
	fi
	[ ! -f "${_log_file}" ] && touch "${_log_file}"
	chmod 644 "${_log_file}"
	chown "${_username}:syslog" "${_log_file}"

	# Start the program
	for ((i = 1; i <= _retries; i++)); do
		info "Starting ${_program_path}/${_program_name} for user ${_username}"
		sudo -u "${_username}" bash -c "nohup ${_program_path}/${_program_name} ${_program_args[*]} >> \"${_log_file}\" 2>&1 & echo \$! > \"${_pid_file}\"" && {
			local _start_time _pid
			_start_time=$(date +%s)
			_pid=$(cat "${_pid_file}")
			while kill -0 "${_pid}" 2>/dev/null; do
				sleep 1
				local _current_time _up_time
				_current_time=$(date +%s)
				_up_time=$((_current_time - _start_time))
				if [ $_up_time -ge $_timeout ]; then
					success "${_program_name} started with PID ${_pid} as user ${_username}"
					return 0
				fi
			done
			error "${_program_name} crashed before reaching minimum up-time of ${_timeout} seconds"
		}
		error "Attempt $i: Failed to start ${_program_path}/${_program_name} for user ${_username}"
		sleep 1
	done
	error "Failed to start ${_program_path}/${_program_name} for user ${_username} after ${_retries} attempts"
	return 1
}

# kill_logged_program_with_pid: Kill a program ran by run_logged_program_with_pid
#
# Usage: kill_logged_program_with_pid <program_name> [<username>] [<timeout>] [<retries>]
#
# Arguments:
#   program_name: Name of the program to exit
#   username: User the program is running as
#   timeout: Timeout duration for each attempt (in seconds)
#   retries: Number of retries for terminating the program
#
# Returns:
#   0 on success, 1 on failure
#
function kill_logged_program_with_pid() {
	local _program_name=$1
	if [ -z "${_program_name}" ]; then
		error "No program name specified"
		return 1
	fi
	local _program_path
	if [[ "${_program_name}" == */* ]]; then
		_program_path=$(dirname "${_program_name}")
		_program_name=$(basename "${_program_name}")
	else
		_program_path=$(dirname "$(which "${_program_name}" || echo "")" || echo "")
	fi
	shift 1
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _timeout
	if [ $# -gt 0 ]; then
		_timeout=$1
		shift 1
	else
		_timeout=10
	fi
	local _retries
	if [ $# -gt 0 ]; then
		_retries=$1
		shift 1
	else
		_retries=3
	fi

	# Straighten out permissions and directories
	local _log_dir _pid_dir _pid_file _pid
	_log_dir="/var/log/${_program_name}"
	if [ ! -d "${_log_dir}" ]; then
		warning "Log folder: ${_log_dir} does not exist, no logs have been output."
	fi
	_pid_dir="/var/run/${_program_name}"
	if [ ! -d "${_pid_dir}" ]; then
		mkdir -p "${_pid_dir}"
		chmod 1777 "${_pid_dir}"
	fi

	# Kill the program
	_pid_file="${_pid_dir}/${_username}_${_program_name}.pid"
	if [ ! -f "${_pid_file}" ]; then
		error "No PID file found for ${_program_name} for user ${_username}."
		return 1
	fi
	_pid=$(cat "${_pid_file}")

	for ((i = 1; i <= _retries; i++)); do
		if kill -0 "${_pid}" 2>/dev/null; then
			timeout "${_timeout}" kill "${_pid}" && {
				success "${_program_path}/${_program_name} with PID ${_pid} has been terminated for user ${_username}."
				rm -f "${_pid_file}"
				return 0
			}
			error "Attempt $i: Failed to terminate ${_program_path}/${_program_name} with PID ${_pid} for user ${_username}"
		else
			warning "No process found with PID ${_pid}."
			rm -f "${_pid_file}"
			return 0
		fi
		sleep 1
	done
	error "Failed to terminate ${_program_path}/${_program_name} with PID ${_pid} for user ${_username} after ${_retries} attempts"
	return 1
}

# restart_logged_program_with_pid: Restart a program ran by run_logged_program_with_pid
#
# Usage: restart_logged_program_with_pid <program_name> [<username>] [<timeout>] [<retries>] [<program_args>] 
#
# Arguments:
#   program_name: Name of the program to restart
#   username: User the program is running as
#   timeout: Timeout duration for each attempt (in seconds)
#   retries: Number of retries for restarting the program
#   program_args: Arguments to pass to the program
#
# Returns:
#   0 on success, 1 on failure
#
function restart_logged_program_with_pid() {
	local _program_name=$1
	if [ -z "${_program_name}" ]; then
		error "No program name specified"
		return 1
	fi
	local _program_path
	if [[ "${_program_name}" == */* ]]; then
		_program_path=$(dirname "${_program_name}")
		_program_name=$(basename "${_program_name}")
	else
		_program_path=$(dirname "$(which "${_program_name}" || echo "")" || echo "")
	fi
	shift 1
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _timeout
	if [ $# -gt 0 ]; then
		_timeout=$1
		shift 1
	else
		_timeout=10
	fi
	local _retries
	if [ $# -gt 0 ]; then
		_retries=$1
		shift 1
	else
		_retries=3
	fi
	declare -a _program_args=($*)

	for ((i = 1; i <= _retries; i++)); do
		if is_logged_program_with_pid_running "${_program_name}" "${_username}"; then
			kill_logged_program_with_pid "${_program_path}/${_program_name}" "${_username}" ${_timeout} ${_retries} && {
				sleep 1
			} || {
				error "Attempt $i: Failed to stop ${_program_path}/${_program_name} for user ${_username}"
				sleep 1
				continue
			}
		fi
		run_logged_program_with_pid "${_program_path}/${_program_name}" "${_username}" ${_timeout} ${_retries} ${_program_args[*]} && {
			success "${_program_path}/${_program_name} restarted for user ${_username}"
			return 0
		} || {
			error "Attempt $i: Failed to start ${_program_path}/${_program_name} for user ${_username}"
		}
		sleep 1
	done
	error "Failed to restart ${_program_path}/${_program_name} for user ${_username} after ${_retries} attempts"
	return 1
}

####################################################################################################
# Core functions
####################################################################################################

# install_pingpong: Install the pingpong service
#
# Usage: install_pingpong <install_dir>
#
# Arguments:
#   install_dir: Installation directory of pingpong
#
# Returns:
#   0 on success, 1 on failure
#
function install_pingpong() {
	local _install_dir
	_install_dir="$1"
	if [ -z "${_install_dir}" ]; then
		error "No installation directory specified."
		return 1
	fi
	if [ ! -d "${_install_dir}" ]; then
		error "Installation directory ${_install_dir} does not exist"
		return 1
	fi
	if ! echo $PATH | grep -q ${_install_dir}; then
		error "Installation directory ${_install_dir} is not on PATH"
		return 1
	fi
	if [ -f "${_install_dir}/bin/PINGPONG" ]; then
		warning "PINGPONG binary already exists in ${_install_dir}/bin"
		return 0
	fi
	shift 1
	info "Installing pingpong to ${_install_dir}/bin"
	fetch_from_url "https://pingpong-build.s3.ap-southeast-1.amazonaws.com/linux/latest/PINGPONG" "${_install_dir}/bin" 0 || {
		error "Failed to fetch pingpong binary"
		return 1
	}
	chmod +x "${_install_dir}/bin/PINGPONG" || {
		error "Failed to set execute permissions on ${_install_dir}/bin/PINGPONG"
		return 1
	}
	success "Pingpong installed to ${_install_dir}/bin"
	return 0
}

# uninstall_pingpong: Uninstall the pingpong service
#
# Usage: uninstall_pingpong <install_dir>
#
# Arguments:
#   install_dir: Installation directory of pingpong
#
# Returns:
#   0 on success, 1 on failure
#
function uninstall_pingpong() {
	local _install_dir
	if [ "$#" -gt 0 ]; then
		_install_dir=$1
		shift 1
	fi
	_install_dir=$(validate_install_dir "${_install_dir}" "PINGPONG")
	info "Uninstalling pingpong from ${_install_dir}"
	rm -f ${_install_dir}/PINGPONG || {
		error "Failed to remove PINGPONG binary."
		return 1
	}
	success "Pingpong uninstalled from ${_install_dir}"
	return 0
}

# load_config: Load pingpong configuration from a JSON file
#
# Usage: load_pingpong_config <config_file> [<install_dir>] [<username>] [<offline>]
#
# Arguments:
#   config_file: JSON configuration file to load into pingpong
#   install_dir: Installation directory of pingpong (defaults to autodetect)
#   username: User to run the pingpong service as (defaults to logged in user)
#   offline: Load configuration in offline mode (defaults to false)
#
# Returns:
#   0 on success, 1 on failure
#
function load_pingpong_config() {
	local _config_file=$1
	_config_file=$(validate_file "${_config_file}") || return $?
	shift 1
	local _install_dir
	if [ $# -gt 0 ]; then
		_install_dir=$1
		shift 1
	fi
	_install_dir=$(validate_install_dir "${_install_dir}" "PINGPONG") || return $?
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _offline
	if [ $# -gt 0 ]; then
		_offline=$1
		shift 1
	else
		_offline=false
	fi
	_offline=$(validate_boolean "${_offline}") || return $?
	if [ "${_offline}" == true ]; then
		local _device_key
		_device_key=$(jq -r '.device_key' $_config_file 2>/dev/null || echo "")
		[[ -n "${_device_key}" && "x${_device_key}x" != "xx" ]] &&
			PINGPONG_ARGS+=("--key ${_device_key}")
	else
		local _aiog_token _aioz_token _grass_token

		_aiog_token=$(jq -r '.aiog_token' $_config_file 2>/dev/null || echo "")
		[[ -n "${_aiog_token}" && "x${_aiog_token}x" != "xx" ]] && \
			sudo -u "${_username}" bash -c "${_install_dir}/PINGPONG config set --0g=${_aiog_token}"

		_aioz_token=$(jq -r '.aioz_token' $_config_file 2>/dev/null || echo "")
		[[ -n "${_aioz_token}" && "x${_aioz_token}x" != "xx" ]] && \
			sudo -u "${_username}" bash -c "${_install_dir}/PINGPONG config set --aioz=${_aioz_token}" 	

		_grass_token=$(jq -r '.grass_token' $_config_file 2>/dev/null || echo "")
		[[ -n "${_grass_token}" && "x${_grass_token}x" != "xx" ]] && \
			sudo -u "${_username}" bash -c "${_install_dir}/PINGPONG config set --grass=${_grass_token}"
	fi

	return 0
}

# save_pingpong_config: Save pingpong configuration to a JSON file
#
# Usage: save_pingpong_config <config_file> [<device_key>] [<aiog_token> [<aioz_token> [<grass_token>]]
#
# Arguments:
#   config_file: JSON configuration file to save pingpong configuration
#   device_key: Device key hash
#   aiog_token: AI0G token
#   aioz_token: AIOZ token
#   grass_token: Grass user token
#
# Returns:
#   0 on success, 1 on failure
#
function save_pingpong_config() {
	local _config_file=$1
	if [ -f "${_config_file}" ]; then
		rm -f "${_config_file}"
	fi
	cat <<-'EOF' >${_config_file}
	{
		"device_key": "",
		"aiog_token": "",
		"aioz_token": "",
		"grass_token": ""
	}
	EOF
	if [ $# -gt 0 ]; then
		local _device_key=$1
		shift 1
	fi
	if [ $# -gt 0 ]; then
		local _aiog_token=$1
		shift 1
	fi
	if [ $# -gt 0 ]; then
		local _aioz_token=$1
		shift 1
	fi
	if [ $# -gt 0 ]; then
		local _grass_token=$1
		shift 1
	fi
	if [ -n "${_device_key}" ]; then
		jq '.device_key = "'${_device_key}'"' $_config_file >$_config_file.tmp && mv $_config_file.tmp $_config_file || return $?
	fi
	if [ -n "${_aiog_token}" ]; then
		jq '.aiog_token = "'${_aiog_token}'"' $_config_file >$_config_file.tmp && mv $_config_file.tmp $_config_file || return $?
	fi
	if [ -n "${_aioz_token}" ]; then
		jq '.aioz_token = "'${_aioz_token}'"' $_config_file >$_config_file.tmp && mv $_config_file.tmp $_config_file || return $?
	fi
	if [ -n "${_grass_token}" ]; then
		jq '.grass_token = "'${_grass_token}'"' $_config_file >$_config_file.tmp && mv $_config_file.tmp $_config_file || return $?
	fi
	success "Configuration saved to: $_config_file"
}

# start_pingpong: Start the pingpong service
#
# Usage: start_pingpong <config_file> [<username>] [<install_dir>]
#
# Arguments:
#   config_file: JSON configuration file to load into pingpong
#   username: User to run the pingpong service as
#   install_dir: Installation directory of pingpong (defaults to autodetect)
#
# Returns:
#   0 on success, 1 on failure
#
function start_pingpong() {
	local _config_file=$1
	__config_file=$(validate_file "${_config_file}") || return $?
	shift 1
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _install_dir
	if [ "$#" -gt 0 ]; then
		_install_dir=$1
		shift 1
	fi
	_install_dir=$(validate_install_dir "${_install_dir}" "PINGPONG") || return $?

	if is_logged_program_with_pid_running "${_install_dir}/PINGPONG" "${_username}"; then
		warning "Pingpong is already running"
		return 0
	fi
	load_pingpong_config "${_config_file}" "${_install_dir}" "${_username}" 1 || return $?
	run_logged_program_with_pid "${_install_dir}/PINGPONG" "${_username}" 15 3 ${PINGPONG_ARGS[*]} || return $?
	load_pingpong_config "${_config_file}" "${_install_dir}" "${_username}" 0 || return $?
	restart_logged_program_with_pid "${_install_dir}/PINGPONG" "${_username}" 15 3 ${PINGPONG_ARGS[*]} || return $?
	success "Pingpong in ${_install_dir} for user ${_username} started successfully"
	return 0
}

# stop_pingpong: Stop the pingpong service
#
# Usage: stop_pingpong [<username>] [<install_dir>]
#
# Arguments:
#
#   username: User to run the pingpong service as (defaults to logged in user)
#   install_dir: Installation directory of pingpong (defaults to autodetect)
#
# Returns:
#   0 on success, 1 on failure
#
function stop_pingpong() {
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _install_dir
	if [ "$#" -gt 0 ]; then
		_install_dir=$1
		shift 1
	fi
	_install_dir=$(validate_install_dir "${_install_dir}" "PINGPONG") || return $?

	info "Stopping pingpong..."
	if ! is_logged_program_with_pid_running "${_install_dir}/PINGPONG" "${_username}"; then
		warning "Pingpong is not running"
		return 0
	fi
	kill_logged_program_with_pid "${_install_dir}/PINGPONG" "${_username}" 15 3 || {
		error "Failed to stop pingpong"
		return 1
	}
	success "Pingpong in ${_install_dir} for user ${_username} stopped successfully"
}

# restart_pingpong: Restart the pingpong service
#
# Usage: restart_pingpong <config_file> [<username>] [<install_dir>]
#
# Arguments:
#
#   config_file: JSON configuration file to load into pingpong
#   username: User to run the pingpong service as (defaults to logged in user)
#   install_dir: Installation directory of pingpong (defaults to autodetect)
#
# Returns:
#   0 on success, 1 on failure
#
function restart_pingpong() {
	local _config_file=$1
	_config_file=$(validate_file "${_config_file}") || return $?
	shift 1
	local _username
	if [ $# -gt 0 ]; then
		_username=$1
		shift 1
	fi
	_username=$(validate_username "${_username}") || return $?
	local _install_dir
	if [ "$#" -gt 0 ]; then
		_install_dir=$1
		shift 1
	fi
	_install_dir=$(validate_install_dir "${_install_dir}" "PINGPONG") || return $?
	load_pingpong_config "${_config_file}" "${_install_dir}" "${_username}" 1 || return $?
	if is_logged_program_with_pid_running "${_install_dir}/PINGPONG" "${_username}"; then
		kill_logged_program_with_pid "${_install_dir}/PINGPONG" "${_username}" 15 3 || {
			error "Failed to stop pingpong"
			return 1
		}
	fi
	run_logged_program_with_pid "${_install_dir}/PINGPONG" "${_username}" 15 3 ${PINGPONG_ARGS[*]} || {
		error "Failed to start pingpong"
		return 1
	}
	success "Pingpong in ${_install_dir} for user ${_username} restarted successfully"
}

####################################################################################################
# Main program
####################################################################################################

# prevent this script from being run as anything but root
if [ "$(id -u)" -ne 0 ]; then
	error "This script must be run as root" 1>&2
	exit 1
fi

parse_args ${CARGS[*]}
case "$ACTION" in
install)
	install_pingpong "$PINGPONG_INSTALL_PREFIX"
	;;
uninstall)
	uninstall_pingpong "$PINGPONG_INSTALL_PREFIX"
	;;
start)
	start_pingpong "$PINGPONG_CONFIG_FILE" "$PINGPONG_USERNAME" "$PINGPONG_INSTALL_PREFIX"
	;;
stop)
	stop_pingpong "$PINGPONG_USERNAME" "$PINGPONG_INSTALL_PREFIX"
	;;
restart)
	restart_pingpong "$PINGPONG_CONFIG_FILE" "$PINGPONG_USERNAME" "$PINGPONG_INSTALL_PREFIX"
	;;
configure)
	save_pingpong_config "$PINGPONG_CONFIG_FILE" "$PINGPONG_DEVICE_KEY" "$PINGPONG_AIOG_TOKEN" "$PINGPONG_AIOZ_TOKEN" "$PINGPONG_GRASS_TOKEN"
	;;
*)
	error "Unknown action: $ACTION"
	usage
	;;
esac
